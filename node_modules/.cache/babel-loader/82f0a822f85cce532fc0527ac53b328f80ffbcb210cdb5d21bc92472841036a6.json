{"ast":null,"code":"import { useMemo as n, useState as o, useRef as e, useEffect as i, useCallback as t, Fragment as r, createElement as l } from \"react\";\nimport { defaultMargin as u, getRelativeCursor as a, getDistance as d, Container as s, useDimensions as c, SvgWrapper as h, ResponsiveWrapper as v } from \"@nivo/core\";\nimport { scaleLinear as f } from \"d3-scale\";\nimport { Delaunay as p } from \"d3-delaunay\";\nimport { useTooltip as g } from \"@nivo/tooltip\";\nimport { jsx as m, jsxs as M, Fragment as b } from \"react/jsx-runtime\";\nfunction k() {\n  return k = Object.assign ? Object.assign.bind() : function (n) {\n    for (var o = 1; o < arguments.length; o++) {\n      var e = arguments[o];\n      for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]);\n    }\n    return n;\n  }, k.apply(this, arguments);\n}\nvar y = {\n    xDomain: [0, 1],\n    yDomain: [0, 1],\n    layers: [\"links\", \"cells\", \"points\", \"bounds\"],\n    enableLinks: !1,\n    linkLineWidth: 1,\n    linkLineColor: \"#bbbbbb\",\n    enableCells: !0,\n    cellLineWidth: 2,\n    cellLineColor: \"#000000\",\n    enablePoints: !0,\n    pointSize: 4,\n    pointColor: \"#666666\",\n    role: \"img\"\n  },\n  C = function (n) {\n    return [n.x, n.y];\n  },\n  L = u,\n  T = \"cursor\",\n  P = \"top\",\n  w = function (n) {\n    var o = n.points,\n      e = n.getNodePosition,\n      i = void 0 === e ? C : e,\n      t = n.margin,\n      r = void 0 === t ? L : t;\n    return o.map(function (n) {\n      var o = i(n),\n        e = o[0],\n        t = o[1];\n      return [e + r.left, t + r.top];\n    });\n  },\n  E = function (n) {\n    var o = n.points,\n      e = n.width,\n      i = n.height,\n      t = n.margin,\n      r = void 0 === t ? L : t,\n      l = n.debug,\n      u = p.from(o),\n      a = l ? u.voronoi([0, 0, r.left + e + r.right, r.top + i + r.bottom]) : void 0;\n    return {\n      points: o,\n      delaunay: u,\n      voronoi: a\n    };\n  },\n  W = function (o) {\n    var e = o.points,\n      i = o.getNodePosition,\n      t = void 0 === i ? C : i,\n      r = o.width,\n      l = o.height,\n      u = o.margin,\n      a = void 0 === u ? L : u,\n      d = o.debug;\n    return n(function () {\n      return E({\n        points: w({\n          points: e,\n          margin: a,\n          getNodePosition: t\n        }),\n        width: r,\n        height: l,\n        margin: a,\n        debug: d\n      });\n    }, [e, r, l, a, d]);\n  },\n  x = function (o) {\n    var e = o.data,\n      i = o.width,\n      t = o.height,\n      r = o.xDomain,\n      l = o.yDomain,\n      u = n(function () {\n        return f().domain(r).range([0, i]);\n      }, [r, i]),\n      a = n(function () {\n        return f().domain(l).range([0, t]);\n      }, [l, t]),\n      d = n(function () {\n        return e.map(function (n) {\n          return {\n            x: u(n.x),\n            y: a(n.y),\n            data: n\n          };\n        });\n      }, [e, u, a]);\n    return n(function () {\n      var n = p.from(d.map(function (n) {\n          return [n.x, n.y];\n        })),\n        o = n.voronoi([0, 0, i, t]);\n      return {\n        points: d,\n        delaunay: n,\n        voronoi: o\n      };\n    }, [d, i, t]);\n  },\n  S = function (o) {\n    var e = o.points,\n      i = o.delaunay,\n      t = o.voronoi;\n    return n(function () {\n      return {\n        points: e,\n        delaunay: i,\n        voronoi: t\n      };\n    }, [e, i, t]);\n  },\n  D = function (r) {\n    var l = r.elementRef,\n      u = r.nodes,\n      s = r.getNodePosition,\n      c = void 0 === s ? C : s,\n      h = r.delaunay,\n      v = r.setCurrent,\n      f = r.margin,\n      p = void 0 === f ? L : f,\n      m = r.detectionRadius,\n      M = void 0 === m ? 1 / 0 : m,\n      b = r.isInteractive,\n      k = void 0 === b || b,\n      y = r.onMouseEnter,\n      w = r.onMouseMove,\n      E = r.onMouseLeave,\n      W = r.onClick,\n      x = r.onTouchStart,\n      S = r.onTouchMove,\n      D = r.onTouchEnd,\n      R = r.enableTouchCrosshair,\n      A = void 0 !== R && R,\n      N = r.tooltip,\n      O = r.tooltipPosition,\n      j = void 0 === O ? T : O,\n      I = r.tooltipAnchor,\n      z = void 0 === I ? P : I,\n      F = o(null),\n      H = F[0],\n      B = F[1],\n      q = e(null);\n    i(function () {\n      q.current = H;\n    }, [q, H]);\n    var G = t(function (n) {\n        if (!l.current) return null;\n        var o = a(l.current, n),\n          e = o[0],\n          i = o[1],\n          t = h.find(e, i),\n          r = void 0 !== t ? u[t] : null;\n        if (r && M !== 1 / 0) {\n          var s = c(r),\n            v = s[0],\n            f = s[1];\n          d(e, i, v + p.left, f + p.top) > M && (t = null, r = null);\n        }\n        return null === t || null === r ? null : [t, r];\n      }, [l, h, u, c, p, M]),\n      J = g(),\n      K = J.showTooltipAt,\n      Q = J.showTooltipFromEvent,\n      U = J.hideTooltip,\n      V = n(function () {\n        if (N) return \"cursor\" === j ? function (n, o) {\n          Q(N(n), o, z);\n        } : function (n) {\n          var o = c(n),\n            e = o[0],\n            i = o[1];\n          K(N(n), [e + p.left, i + p.top], z);\n        };\n      }, [K, Q, N, j, z, c, p]),\n      X = t(function (n) {\n        var o = G(n);\n        if (B(o), null == v || v(o ? o[1] : null), o) {\n          var e = o[1];\n          null == V || V(e, n), null == y || y(o[1], n);\n        }\n      }, [G, B, v, V, y]),\n      Y = t(function (n) {\n        var o = G(n);\n        if (B(o), o) {\n          var e = o[0],\n            i = o[1];\n          if (null == v || v(i), null == V || V(i, n), q.current) {\n            var t = q.current,\n              r = t[0],\n              l = t[1];\n            e !== r ? null == E || E(l, n) : null == w || w(i, n);\n          } else null == y || y(i, n);\n        } else null == v || v(null), null == U || U(), q.current && (null == E || E(q.current[1], n));\n      }, [G, B, q, y, w, E, V, U]),\n      Z = t(function (n) {\n        B(null), null == v || v(null), U(), E && q.current && E(q.current[1], n);\n      }, [B, v, q, U, E]),\n      $ = t(function (n) {\n        var o = G(n);\n        B(o), o && (null == W || W(o[1], n));\n      }, [G, B, W]),\n      _ = t(function (n) {\n        var o = G(n);\n        A && (B(o), null == v || v(o ? o[1] : null)), o && (null == x || x(o[1], n));\n      }, [G, B, v, A, x]),\n      nn = t(function (n) {\n        var o = G(n);\n        A && (B(o), null == v || v(o ? o[1] : null)), o && (null == S || S(o[1], n));\n      }, [G, B, v, A, S]),\n      on = t(function (n) {\n        A && (B(null), null == v || v(null)), D && q.current && D(q.current[1], n);\n      }, [A, B, v, D, q]);\n    return {\n      current: H,\n      handleMouseEnter: k ? X : void 0,\n      handleMouseMove: k ? Y : void 0,\n      handleMouseLeave: k ? Z : void 0,\n      handleClick: k ? $ : void 0,\n      handleTouchStart: k ? _ : void 0,\n      handleTouchMove: k ? nn : void 0,\n      handleTouchEnd: k ? on : void 0\n    };\n  },\n  R = function (n) {\n    var o = n.elementRef,\n      e = n.nodes,\n      i = n.getNodePosition,\n      t = n.width,\n      r = n.height,\n      l = n.margin,\n      u = void 0 === l ? L : l,\n      a = n.isInteractive,\n      d = void 0 === a || a,\n      s = n.detectionRadius,\n      c = void 0 === s ? 1 / 0 : s,\n      h = n.setCurrent,\n      v = n.onMouseEnter,\n      f = n.onMouseMove,\n      p = n.onMouseLeave,\n      g = n.onClick,\n      m = n.tooltip,\n      M = n.tooltipPosition,\n      b = void 0 === M ? T : M,\n      k = n.tooltipAnchor,\n      y = void 0 === k ? P : k,\n      C = n.debug,\n      w = W({\n        points: e,\n        getNodePosition: i,\n        width: t,\n        height: r,\n        margin: u,\n        debug: void 0 !== C && C\n      }),\n      E = w.delaunay,\n      x = w.voronoi,\n      S = D({\n        elementRef: o,\n        nodes: e,\n        margin: u,\n        setCurrent: h,\n        delaunay: E,\n        detectionRadius: c,\n        isInteractive: d,\n        onMouseEnter: v,\n        onMouseMove: f,\n        onMouseLeave: p,\n        onClick: g,\n        tooltip: m,\n        tooltipPosition: b,\n        tooltipAnchor: y\n      }),\n      R = S.handleMouseEnter,\n      A = S.handleMouseMove,\n      N = S.handleMouseLeave,\n      O = S.handleClick;\n    return {\n      delaunay: E,\n      voronoi: x,\n      current: S.current,\n      handleMouseEnter: R,\n      handleMouseMove: A,\n      handleMouseLeave: N,\n      handleClick: O\n    };\n  },\n  A = [\"theme\"],\n  N = function (n) {\n    var o = n.data,\n      e = n.width,\n      i = n.height,\n      t = n.margin,\n      u = n.layers,\n      a = void 0 === u ? y.layers : u,\n      d = n.xDomain,\n      s = void 0 === d ? y.xDomain : d,\n      v = n.yDomain,\n      f = void 0 === v ? y.yDomain : v,\n      p = n.enableLinks,\n      g = void 0 === p ? y.enableLinks : p,\n      M = n.linkLineWidth,\n      b = void 0 === M ? y.linkLineWidth : M,\n      k = n.linkLineColor,\n      C = void 0 === k ? y.linkLineColor : k,\n      L = n.enableCells,\n      T = void 0 === L ? y.enableCells : L,\n      P = n.cellLineWidth,\n      w = void 0 === P ? y.cellLineWidth : P,\n      E = n.cellLineColor,\n      W = void 0 === E ? y.cellLineColor : E,\n      D = n.enablePoints,\n      R = void 0 === D ? y.enableCells : D,\n      A = n.pointSize,\n      N = void 0 === A ? y.pointSize : A,\n      O = n.pointColor,\n      j = void 0 === O ? y.pointColor : O,\n      I = n.role,\n      z = void 0 === I ? y.role : I,\n      F = c(e, i, t),\n      H = F.outerWidth,\n      B = F.outerHeight,\n      q = F.margin,\n      G = F.innerWidth,\n      J = F.innerHeight,\n      K = x({\n        data: o,\n        width: G,\n        height: J,\n        xDomain: s,\n        yDomain: f\n      }),\n      Q = K.points,\n      U = K.delaunay,\n      V = K.voronoi,\n      X = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null\n      };\n    g && a.includes(\"links\") && (X.links = m(\"path\", {\n      stroke: C,\n      strokeWidth: b,\n      fill: \"none\",\n      d: U.render()\n    }, \"links\")), T && a.includes(\"cells\") && (X.cells = m(\"path\", {\n      d: V.render(),\n      fill: \"none\",\n      stroke: W,\n      strokeWidth: w\n    }, \"cells\")), R && a.includes(\"points\") && (X.points = m(\"path\", {\n      stroke: \"none\",\n      fill: j,\n      d: U.renderPoints(void 0, N / 2)\n    }, \"points\")), a.includes(\"bounds\") && (X.bounds = m(\"path\", {\n      fill: \"none\",\n      stroke: W,\n      strokeWidth: w,\n      d: V.renderBounds()\n    }, \"bounds\"));\n    var Y = S({\n      points: Q,\n      delaunay: U,\n      voronoi: V\n    });\n    return m(h, {\n      width: H,\n      height: B,\n      margin: q,\n      role: z,\n      children: a.map(function (n, o) {\n        return void 0 !== X[n] ? X[n] : \"function\" == typeof n ? m(r, {\n          children: l(n, Y)\n        }, o) : null;\n      })\n    });\n  },\n  O = function (n) {\n    var o = n.theme,\n      e = function (n, o) {\n        if (null == n) return {};\n        var e,\n          i,\n          t = {},\n          r = Object.keys(n);\n        for (i = 0; i < r.length; i++) e = r[i], o.indexOf(e) >= 0 || (t[e] = n[e]);\n        return t;\n      }(n, A);\n    return m(s, {\n      isInteractive: !1,\n      animate: !1,\n      theme: o,\n      children: m(N, k({}, e))\n    });\n  },\n  j = function (n) {\n    return m(v, {\n      children: function (o) {\n        var e = o.width,\n          i = o.height;\n        return m(O, k({\n          width: e,\n          height: i\n        }, n));\n      }\n    });\n  },\n  I = function (o) {\n    var i = o.nodes,\n      t = o.width,\n      r = o.height,\n      l = o.margin,\n      u = void 0 === l ? L : l,\n      a = o.getNodePosition,\n      d = o.setCurrent,\n      s = o.onMouseEnter,\n      c = o.onMouseMove,\n      h = o.onMouseLeave,\n      v = o.onClick,\n      f = o.onTouchStart,\n      p = o.onTouchMove,\n      g = o.onTouchEnd,\n      k = o.enableTouchCrosshair,\n      y = void 0 !== k && k,\n      C = o.detectionRadius,\n      w = void 0 === C ? 1 / 0 : C,\n      E = o.tooltip,\n      x = o.tooltipPosition,\n      S = void 0 === x ? T : x,\n      R = o.tooltipAnchor,\n      A = void 0 === R ? P : R,\n      N = o.debug,\n      O = e(null),\n      j = W({\n        points: i,\n        getNodePosition: a,\n        width: t,\n        height: r,\n        margin: u,\n        debug: N\n      }),\n      I = j.delaunay,\n      z = j.voronoi,\n      F = D({\n        elementRef: O,\n        nodes: i,\n        delaunay: I,\n        margin: u,\n        detectionRadius: w,\n        setCurrent: d,\n        onMouseEnter: s,\n        onMouseMove: c,\n        onMouseLeave: h,\n        onClick: v,\n        onTouchStart: f,\n        onTouchMove: p,\n        onTouchEnd: g,\n        enableTouchCrosshair: y,\n        tooltip: E,\n        tooltipPosition: S,\n        tooltipAnchor: A\n      }),\n      H = F.current,\n      B = F.handleMouseEnter,\n      q = F.handleMouseMove,\n      G = F.handleMouseLeave,\n      J = F.handleClick,\n      K = F.handleTouchStart,\n      Q = F.handleTouchMove,\n      U = F.handleTouchEnd,\n      V = n(function () {\n        if (N && z) return z.render();\n      }, [N, z]);\n    return M(\"g\", {\n      ref: O,\n      transform: \"translate(\" + -u.left + \",\" + -u.top + \")\",\n      children: [N && z && M(b, {\n        children: [m(\"path\", {\n          d: V,\n          stroke: \"red\",\n          strokeWidth: 1,\n          opacity: .75\n        }), w < 1 / 0 && m(\"path\", {\n          stroke: \"red\",\n          strokeWidth: .35,\n          fill: \"none\",\n          d: I.renderPoints(void 0, w)\n        }), H && m(\"path\", {\n          fill: \"pink\",\n          opacity: .35,\n          d: z.renderCell(H[0])\n        })]\n      }), m(\"rect\", {\n        \"data-ref\": \"mesh-interceptor\",\n        width: u.left + t + u.right,\n        height: u.top + r + u.bottom,\n        fill: \"red\",\n        opacity: 0,\n        style: {\n          cursor: \"auto\"\n        },\n        onMouseEnter: B,\n        onMouseMove: q,\n        onMouseLeave: G,\n        onTouchStart: K,\n        onTouchMove: Q,\n        onTouchEnd: U,\n        onClick: J\n      })]\n    });\n  },\n  z = function (n, o) {\n    n.save(), n.globalAlpha = .75, n.beginPath(), o.render(n), n.strokeStyle = \"red\", n.lineWidth = 1, n.stroke(), n.restore();\n  },\n  F = function (n, o, e) {\n    n.save(), n.globalAlpha = .15, n.beginPath(), o.renderPoints(n, e), n.strokeStyle = \"red\", n.lineWidth = 1, n.stroke(), n.restore();\n  },\n  H = function (n, o, e) {\n    n.save(), n.globalAlpha = .35, n.beginPath(), o.renderCell(e, n), n.fillStyle = \"pink\", n.fill(), n.restore();\n  },\n  B = function (n, o) {\n    var e = o.delaunay,\n      i = o.voronoi,\n      t = o.detectionRadius,\n      r = o.index;\n    z(n, i), t < 1 / 0 && F(n, e, t), null !== r && H(n, i, r);\n  };\nexport { I as Mesh, j as ResponsiveVoronoi, O as Voronoi, E as computeMesh, w as computeMeshPoints, y as defaultVoronoiProps, B as renderDebugToCanvas, F as renderDelaunayPointsToCanvas, H as renderVoronoiCellToCanvas, z as renderVoronoiToCanvas, R as useMesh, D as useMeshEvents, x as useVoronoi, S as useVoronoiLayerContext, W as useVoronoiMesh };","map":{"version":3,"names":["y","xDomain","yDomain","layers","enableLinks","linkLineWidth","linkLineColor","enableCells","cellLineWidth","cellLineColor","enablePoints","pointSize","pointColor","role","C","defaultNodePositionAccessor","n","x","L","u","T","P","w","computeMeshPoints","o","points","e","getNodePosition","i","t","margin","r","map","left","top","E","computeMesh","width","height","l","debug","p","from","a","voronoi","right","bottom","delaunay","W","useVoronoiMesh","d","useVoronoi","data","f","domain","range","S","useVoronoiLayerContext","D","useMeshEvents","elementRef","nodes","s","c","h","v","setCurrent","m","detectionRadius","M","b","isInteractive","k","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","R","enableTouchCrosshair","A","N","tooltip","O","tooltipPosition","j","I","tooltipAnchor","z","F","H","B","q","current","G","find","J","g","K","showTooltipAt","Q","showTooltipFromEvent","U","hideTooltip","V","X","Y","Z","$","_","nn","on","handleMouseEnter","handleMouseMove","handleMouseLeave","handleClick","handleTouchStart","handleTouchMove","handleTouchEnd","useMesh","InnerVoronoi","outerWidth","outerHeight","innerWidth","innerHeight","links","cells","bounds","includes","stroke","strokeWidth","fill","render","renderPoints","renderBounds","children","Voronoi","theme","Object","keys","length","indexOf","animate","ResponsiveVoronoi","Mesh","ref","transform","opacity","renderCell","style","cursor","renderVoronoiToCanvas","save","globalAlpha","beginPath","strokeStyle","lineWidth","restore","renderDelaunayPointsToCanvas","renderVoronoiCellToCanvas","fillStyle","renderDebugToCanvas","index","defaultVoronoiProps"],"sources":["/Users/wonseok/Desktop/react/new/node_modules/@nivo/voronoi/src/props.ts","/Users/wonseok/Desktop/react/new/node_modules/@nivo/voronoi/src/defaults.ts","/Users/wonseok/Desktop/react/new/node_modules/@nivo/voronoi/src/computeMesh.ts","/Users/wonseok/Desktop/react/new/node_modules/@nivo/voronoi/src/hooks.ts","/Users/wonseok/Desktop/react/new/node_modules/@nivo/voronoi/src/Voronoi.tsx","/Users/wonseok/Desktop/react/new/node_modules/@nivo/voronoi/src/ResponsiveVoronoi.tsx","/Users/wonseok/Desktop/react/new/node_modules/@nivo/voronoi/src/Mesh.tsx","/Users/wonseok/Desktop/react/new/node_modules/@nivo/voronoi/src/meshCanvas.ts"],"sourcesContent":["import { VoronoiDomain, VoronoiLayer } from './types'\n\nexport const defaultVoronoiProps = {\n    xDomain: [0, 1] as VoronoiDomain,\n    yDomain: [0, 1] as VoronoiDomain,\n    layers: ['links', 'cells', 'points', 'bounds'] as VoronoiLayer[],\n    enableLinks: false,\n    linkLineWidth: 1,\n    linkLineColor: '#bbbbbb',\n    enableCells: true,\n    cellLineWidth: 2,\n    cellLineColor: '#000000',\n    enablePoints: true,\n    pointSize: 4,\n    pointColor: '#666666',\n    role: 'img',\n}\n","import { Margin, defaultMargin as coreDefaultMargin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\n\nexport const defaultNodePositionAccessor = (node: {\n    x: number\n    y: number\n}): [x: number, y: number] => [node.x, node.y]\n\nexport const defaultMargin: Margin = coreDefaultMargin\n\nexport const defaultTooltipPosition: TooltipPosition = 'cursor'\nexport const defaultTooltipAnchor: TooltipAnchor = 'top'\n","import { Delaunay } from 'd3-delaunay'\nimport { Margin } from '@nivo/core'\nimport { NodePositionAccessor } from './types'\nimport { defaultNodePositionAccessor, defaultMargin } from './defaults'\n\n/**\n * The delaunay generator requires an array\n * where each point is defined as an array\n * of 2 elements: [x: number, y: number].\n *\n * Points represent the raw input data\n * and x/y represent accessors to x & y.\n */\nexport const computeMeshPoints = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    margin = defaultMargin,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    margin?: Margin\n}): [number, number][] => {\n    return points.map(node => {\n        const [x, y] = getNodePosition(node)\n\n        return [x + margin.left, y + margin.top]\n    })\n}\n\nexport const computeMesh = ({\n    points,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly [number, number][]\n    width: number\n    height: number\n    margin?: Margin\n    debug?: boolean\n}) => {\n    const delaunay = Delaunay.from(points)\n    const voronoi = debug\n        ? delaunay.voronoi([\n              0,\n              0,\n              margin.left + width + margin.right,\n              margin.top + height + margin.bottom,\n          ])\n        : undefined\n\n    return { points, delaunay, voronoi }\n}\n","import {\n    MouseEvent,\n    MutableRefObject,\n    TouchEvent,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n    useState,\n} from 'react'\nimport { scaleLinear } from 'd3-scale'\nimport { Delaunay } from 'd3-delaunay'\nimport { getDistance, getRelativeCursor, Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition, useTooltip } from '@nivo/tooltip'\nimport { computeMeshPoints, computeMesh } from './computeMesh'\nimport {\n    VoronoiCommonProps,\n    VoronoiDatum,\n    VoronoiCustomLayerProps,\n    NodeMouseHandler,\n    // DatumTouchHandler,\n    NodePositionAccessor,\n    NodeTouchHandler,\n} from './types'\nimport {\n    defaultMargin,\n    defaultNodePositionAccessor,\n    defaultTooltipPosition,\n    defaultTooltipAnchor,\n} from './defaults'\n\nexport const useVoronoiMesh = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    // Margins are added to the chart's dimensions, so that mouse detection\n    // also works inside the margins, omit if that's not what you want.\n    // When including the margins, we recommend to set a `detectionRadius` as well.\n    margin?: Margin\n    width: number\n    height: number\n    debug?: boolean\n}) =>\n    useMemo(\n        () =>\n            computeMesh({\n                points: computeMeshPoints<Node>({ points, margin, getNodePosition }),\n                width,\n                height,\n                margin,\n                debug,\n            }),\n        [points, width, height, margin, debug]\n    )\n\nexport const useVoronoi = ({\n    data,\n    width,\n    height,\n    xDomain,\n    yDomain,\n}: {\n    data: VoronoiDatum[]\n    width: number\n    height: number\n    xDomain: VoronoiCommonProps['xDomain']\n    yDomain: VoronoiCommonProps['yDomain']\n}) => {\n    const xScale = useMemo(() => scaleLinear().domain(xDomain).range([0, width]), [xDomain, width])\n    const yScale = useMemo(\n        () => scaleLinear().domain(yDomain).range([0, height]),\n        [yDomain, height]\n    )\n\n    const points = useMemo(\n        () =>\n            data.map(d => ({\n                x: xScale(d.x),\n                y: yScale(d.y),\n                data: d,\n            })),\n        [data, xScale, yScale]\n    )\n\n    return useMemo(() => {\n        const delaunay = Delaunay.from(points.map(p => [p.x, p.y]))\n        const voronoi = delaunay.voronoi([0, 0, width, height])\n\n        return {\n            points,\n            delaunay,\n            voronoi,\n        }\n    }, [points, width, height])\n}\n\n/**\n * Memoize the context to pass to custom layers.\n */\nexport const useVoronoiLayerContext = ({\n    points,\n    delaunay,\n    voronoi,\n}: VoronoiCustomLayerProps): VoronoiCustomLayerProps =>\n    useMemo(\n        () => ({\n            points,\n            delaunay,\n            voronoi,\n        }),\n        [points, delaunay, voronoi]\n    )\n\nexport const useMeshEvents = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    delaunay,\n    setCurrent: setCurrentNode,\n    margin = defaultMargin,\n    detectionRadius = Infinity,\n    isInteractive = true,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    delaunay: Delaunay<Node>\n    setCurrent?: (node: Node | null) => void\n    margin?: Margin\n    detectionRadius?: number\n    isInteractive?: boolean\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n}) => {\n    // Store the index of the current point and the current node.\n    const [current, setCurrent] = useState<[number, Node] | null>(null)\n\n    // Keep track of the previous index and node, this is needed as we don't have enter/leave events\n    // for each node because we use a single rect element to capture events.\n    const previous = useRef<[number, Node] | null>(null)\n\n    useEffect(() => {\n        previous.current = current\n    }, [previous, current])\n\n    const findNode = useCallback(\n        (event: MouseEvent<ElementType> | TouchEvent<ElementType>): null | [number, Node] => {\n            if (!elementRef.current) return null\n\n            const [x, y] = getRelativeCursor(elementRef.current, event)\n\n            let index: number | null = delaunay.find(x, y)\n            let node = index !== undefined ? nodes[index] : null\n\n            if (node && detectionRadius !== Infinity) {\n                const [nodeX, nodeY] = getNodePosition(node)\n                if (getDistance(x, y, nodeX + margin.left, nodeY + margin.top) > detectionRadius) {\n                    index = null\n                    node = null\n                }\n            }\n\n            if (index === null || node === null) return null\n\n            return [index, node]\n        },\n        [elementRef, delaunay, nodes, getNodePosition, margin, detectionRadius]\n    )\n\n    const { showTooltipAt, showTooltipFromEvent, hideTooltip } = useTooltip()\n    const showTooltip = useMemo(() => {\n        if (!tooltip) return undefined\n\n        if (tooltipPosition === 'cursor') {\n            // Following the cursor.\n            return (node: Node, event: MouseEvent<ElementType>) => {\n                showTooltipFromEvent(tooltip(node), event, tooltipAnchor)\n            }\n        }\n\n        // Fixed at the node's position.\n        return (node: Node) => {\n            const [x, y] = getNodePosition(node)\n            showTooltipAt(tooltip(node), [x + margin.left, y + margin.top], tooltipAnchor)\n        }\n    }, [\n        showTooltipAt,\n        showTooltipFromEvent,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n        getNodePosition,\n        margin,\n    ])\n\n    // Mouse enter only occurs when entering the main element,\n    // not for each node.\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n            setCurrentNode?.(match ? match[1] : null)\n\n            if (match) {\n                const node = match[1]\n\n                showTooltip?.(node, event)\n                onMouseEnter?.(match[1], event)\n            }\n        },\n        [findNode, setCurrent, setCurrentNode, showTooltip, onMouseEnter]\n    )\n\n    // Handle mouse enter/move/leave, relying on `previous` to simulate events.\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) {\n                const [index, node] = match\n\n                setCurrentNode?.(node)\n                showTooltip?.(node, event)\n\n                if (previous.current) {\n                    const [previousIndex, previousNode] = previous.current\n                    if (index !== previousIndex) {\n                        // Simulate an enter event if the previous index is different.\n                        onMouseLeave?.(previousNode, event)\n                    } else {\n                        // If it's the same, trigger a regular move event.\n                        onMouseMove?.(node, event)\n                    }\n                } else {\n                    onMouseEnter?.(node, event)\n                }\n            } else {\n                setCurrentNode?.(null)\n                hideTooltip?.()\n\n                if (previous.current) {\n                    // Simulate a leave event if there's a previous node.\n                    onMouseLeave?.(previous.current[1], event)\n                }\n            }\n        },\n        [\n            findNode,\n            setCurrent,\n            previous,\n            onMouseEnter,\n            onMouseMove,\n            onMouseLeave,\n            showTooltip,\n            hideTooltip,\n        ]\n    )\n\n    // Mouse leave only occurs when leaving the main element,\n    // not for each node.\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            setCurrent(null)\n            setCurrentNode?.(null)\n\n            hideTooltip()\n\n            if (onMouseLeave && previous.current) {\n                onMouseLeave(previous.current[1], event)\n            }\n        },\n        [setCurrent, setCurrentNode, previous, hideTooltip, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            match && onClick?.(match[1], event)\n        },\n        [findNode, setCurrent, onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            match && onTouchStart?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchStart]\n    )\n\n    const handleTouchMove = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            match && onTouchMove?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchMove]\n    )\n\n    const handleTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            if (enableTouchCrosshair) {\n                setCurrent(null)\n                setCurrentNode?.(null)\n            }\n\n            if (onTouchEnd && previous.current) {\n                onTouchEnd(previous.current[1], event)\n            }\n        },\n        [enableTouchCrosshair, setCurrent, setCurrentNode, onTouchEnd, previous]\n    )\n\n    return {\n        current,\n        handleMouseEnter: isInteractive ? handleMouseEnter : undefined,\n        handleMouseMove: isInteractive ? handleMouseMove : undefined,\n        handleMouseLeave: isInteractive ? handleMouseLeave : undefined,\n        handleClick: isInteractive ? handleClick : undefined,\n        handleTouchStart: isInteractive ? handleTouchStart : undefined,\n        handleTouchMove: isInteractive ? handleTouchMove : undefined,\n        handleTouchEnd: isInteractive ? handleTouchEnd : undefined,\n    }\n}\n\n/**\n * Compute a voronoi mesh and corresponding events.\n */\nexport const useMesh = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition,\n    width,\n    height,\n    margin = defaultMargin,\n    isInteractive = true,\n    detectionRadius = Infinity,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug = false,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    width: number\n    height: number\n    margin?: Margin\n    isInteractive?: boolean\n    detectionRadius?: number\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    debug?: boolean\n}) => {\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const { handleMouseEnter, handleMouseMove, handleMouseLeave, handleClick, current } =\n        useMeshEvents<Node, ElementType>({\n            elementRef,\n            nodes,\n            margin,\n            setCurrent,\n            delaunay,\n            detectionRadius,\n            isInteractive,\n            onMouseEnter,\n            onMouseMove,\n            onMouseLeave,\n            onClick,\n            tooltip,\n            tooltipPosition,\n            tooltipAnchor,\n        })\n\n    return {\n        delaunay,\n        voronoi,\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleClick,\n    }\n}\n","import { createElement, Fragment, ReactNode } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { VoronoiSvgProps, VoronoiLayerId } from './types'\nimport { defaultVoronoiProps } from './props'\nimport { useVoronoi, useVoronoiLayerContext } from './hooks'\n\ntype InnerVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>\n\nconst InnerVoronoi = ({\n    data,\n    width,\n    height,\n    margin: partialMargin,\n    layers = defaultVoronoiProps.layers,\n    xDomain = defaultVoronoiProps.xDomain,\n    yDomain = defaultVoronoiProps.yDomain,\n    enableLinks = defaultVoronoiProps.enableLinks,\n    linkLineWidth = defaultVoronoiProps.linkLineWidth,\n    linkLineColor = defaultVoronoiProps.linkLineColor,\n    enableCells = defaultVoronoiProps.enableCells,\n    cellLineWidth = defaultVoronoiProps.cellLineWidth,\n    cellLineColor = defaultVoronoiProps.cellLineColor,\n    enablePoints = defaultVoronoiProps.enableCells,\n    pointSize = defaultVoronoiProps.pointSize,\n    pointColor = defaultVoronoiProps.pointColor,\n    role = defaultVoronoiProps.role,\n}: InnerVoronoiProps) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { points, delaunay, voronoi } = useVoronoi({\n        data,\n        width: innerWidth,\n        height: innerHeight,\n        xDomain,\n        yDomain,\n    })\n\n    const layerById: Record<VoronoiLayerId, ReactNode> = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null,\n    }\n\n    if (enableLinks && layers.includes('links')) {\n        layerById.links = (\n            <path\n                key=\"links\"\n                stroke={linkLineColor}\n                strokeWidth={linkLineWidth}\n                fill=\"none\"\n                d={delaunay.render()}\n            />\n        )\n    }\n\n    if (enableCells && layers.includes('cells')) {\n        layerById.cells = (\n            <path\n                key=\"cells\"\n                d={voronoi.render()}\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n            />\n        )\n    }\n\n    if (enablePoints && layers.includes('points')) {\n        layerById.points = (\n            <path\n                key=\"points\"\n                stroke=\"none\"\n                fill={pointColor}\n                d={delaunay.renderPoints(undefined, pointSize / 2)}\n            />\n        )\n    }\n\n    if (layers.includes('bounds')) {\n        layerById.bounds = (\n            <path\n                key=\"bounds\"\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n                d={voronoi.renderBounds()}\n            />\n        )\n    }\n\n    const layerContext = useVoronoiLayerContext({\n        points,\n        delaunay,\n        voronoi,\n    })\n\n    return (\n        <SvgWrapper width={outerWidth} height={outerHeight} margin={margin} role={role}>\n            {layers.map((layer, i) => {\n                if (layerById[layer as VoronoiLayerId] !== undefined) {\n                    return layerById[layer as VoronoiLayerId]\n                }\n\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Voronoi = ({\n    theme,\n    ...otherProps\n}: Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>) => (\n    <Container isInteractive={false} animate={false} theme={theme}>\n        <InnerVoronoi {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { VoronoiSvgProps } from './types'\nimport { Voronoi } from './Voronoi'\n\ntype ResponsiveVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data'>\n\nexport const ResponsiveVoronoi = (props: ResponsiveVoronoiProps) => (\n    <ResponsiveWrapper>\n        {({ width, height }: { width: number; height: number }) => (\n            <Voronoi width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n","import { useMemo, useRef } from 'react'\nimport { Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\nimport { useVoronoiMesh, useMeshEvents } from './hooks'\nimport { NodeMouseHandler, NodePositionAccessor, NodeTouchHandler } from './types'\nimport { defaultMargin, defaultTooltipAnchor, defaultTooltipPosition } from './defaults'\n\ninterface MeshProps<Node> {\n    nodes: Node[]\n    width: number\n    height: number\n    margin?: Margin\n    getNodePosition?: NodePositionAccessor<Node>\n    // Can be used in case you want to keep track of the current node externally,\n    // the current node being the last hovered node.\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    // Restrict the node detection to a given radius, default to `Infinity`.\n    detectionRadius?: number\n    // If specified, tooltips are going to be handled automatically.\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    // Display the voronoi mesh for debugging purpose.\n    debug?: boolean\n}\n\nexport const Mesh = <Node,>({\n    nodes,\n    width,\n    height,\n    margin = defaultMargin,\n    getNodePosition,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    detectionRadius = Infinity,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug,\n}: MeshProps<Node>) => {\n    const elementRef = useRef<SVGRectElement | null>(null)\n\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const {\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleClick,\n        handleTouchStart,\n        handleTouchMove,\n        handleTouchEnd,\n    } = useMeshEvents<Node, SVGRectElement>({\n        elementRef,\n        nodes,\n        delaunay,\n        margin,\n        detectionRadius,\n        setCurrent,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        enableTouchCrosshair,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n    })\n\n    const voronoiPath = useMemo(() => {\n        if (debug && voronoi) return voronoi.render()\n        return undefined\n    }, [debug, voronoi])\n\n    return (\n        <g ref={elementRef} transform={`translate(${-margin.left},${-margin.top})`}>\n            {debug && voronoi && (\n                <>\n                    <path d={voronoiPath} stroke=\"red\" strokeWidth={1} opacity={0.75} />\n                    {detectionRadius < Infinity && (\n                        <path\n                            stroke=\"red\"\n                            strokeWidth={0.35}\n                            fill=\"none\"\n                            d={delaunay.renderPoints(undefined, detectionRadius)}\n                        />\n                    )}\n                    {/* highlight the current cell */}\n                    {current && (\n                        <path fill=\"pink\" opacity={0.35} d={voronoi.renderCell(current[0])} />\n                    )}\n                </>\n            )}\n            {/* transparent rect to intercept mouse events */}\n            <rect\n                data-ref=\"mesh-interceptor\"\n                width={margin.left + width + margin.right}\n                height={margin.top + height + margin.bottom}\n                fill=\"red\"\n                opacity={0}\n                style={{ cursor: 'auto' }}\n                onMouseEnter={handleMouseEnter}\n                onMouseMove={handleMouseMove}\n                onMouseLeave={handleMouseLeave}\n                onTouchStart={handleTouchStart}\n                onTouchMove={handleTouchMove}\n                onTouchEnd={handleTouchEnd}\n                onClick={handleClick}\n            />\n        </g>\n    )\n}\n","import { Delaunay, Voronoi } from 'd3-delaunay'\n\nexport const renderVoronoiToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.75\n    ctx.beginPath()\n    voronoi.render(ctx)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderDelaunayPointsToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    delaunay: Delaunay<Delaunay.Point>,\n    radius: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.15\n    ctx.beginPath()\n    delaunay.renderPoints(ctx, radius)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderVoronoiCellToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>,\n    index: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.35\n    ctx.beginPath()\n    voronoi.renderCell(index, ctx)\n    ctx.fillStyle = 'pink'\n    ctx.fill()\n\n    ctx.restore()\n}\n\nexport const renderDebugToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        delaunay,\n        voronoi,\n        detectionRadius,\n        index,\n    }: {\n        delaunay: Delaunay<Delaunay.Point>\n        voronoi: Voronoi<Delaunay.Point>\n        detectionRadius: number\n        index: number | null\n    }\n) => {\n    renderVoronoiToCanvas(ctx, voronoi)\n\n    if (detectionRadius < Infinity) {\n        renderDelaunayPointsToCanvas(ctx, delaunay, detectionRadius)\n    }\n\n    if (index !== null) {\n        renderVoronoiCellToCanvas(ctx, voronoi, index)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}