{"ast":null,"code":"import { memo as e, useMemo as o, useState as i, useCallback as t, createElement as n, Fragment as r, forwardRef as a, useRef as l, useEffect as s } from \"react\";\nimport { useTheme as c, curveFromProp as u, useValueFormatter as d, useMotionConfig as h, useAnimatedPath as f, getLabelGenerator as v, DotsItem as p, withContainer as m, useDimensions as g, CartesianMarkers as y, bindDefs as x, SvgWrapper as b, ResponsiveWrapper as S, getRelativeCursor as M, isCursorInRect as C } from \"@nivo/core\";\nimport { useOrdinalColorScale as w, useInheritedColor as T } from \"@nivo/colors\";\nimport { Grid as k, Axes as B, renderGridLinesToCanvas as W, renderAxesToCanvas as E } from \"@nivo/axes\";\nimport { BoxLegendSvg as L, renderLegendToCanvas as G } from \"@nivo/legends\";\nimport { BasicTooltip as P, TableTooltip as F, Chip as O, useTooltip as V, Crosshair as Y } from \"@nivo/tooltip\";\nimport { line as R, area as I } from \"d3-shape\";\nimport { computeXYScalesForSeries as A } from \"@nivo/scales\";\nimport H from \"lodash/uniqueId\";\nimport { jsx as X, jsxs as z } from \"react/jsx-runtime\";\nimport { useSpring as j, animated as D } from \"@react-spring/web\";\nimport { Mesh as q, useVoronoiMesh as J, renderVoronoiToCanvas as K, renderVoronoiCellToCanvas as N } from \"@nivo/voronoi\";\nfunction Q() {\n  return Q = Object.assign ? Object.assign.bind() : function (e) {\n    for (var o = 1; o < arguments.length; o++) {\n      var i = arguments[o];\n      for (var t in i) Object.prototype.hasOwnProperty.call(i, t) && (e[t] = i[t]);\n    }\n    return e;\n  }, Q.apply(this, arguments);\n}\nvar U = e(function (e) {\n    var o = e.point;\n    return X(P, {\n      id: z(\"span\", {\n        children: [\"x: \", X(\"strong\", {\n          children: o.data.xFormatted\n        }), \", y:\", \" \", X(\"strong\", {\n          children: o.data.yFormatted\n        })]\n      }),\n      enableChip: !0,\n      color: o.serieColor\n    });\n  }),\n  Z = e(function (e) {\n    var o = e.slice,\n      i = e.axis,\n      t = c(),\n      n = \"x\" === i ? \"y\" : \"x\";\n    return X(F, {\n      rows: o.points.map(function (e) {\n        return [X(O, {\n          color: e.serieColor,\n          style: t.tooltip.chip\n        }, \"chip\"), e.serieId, X(\"span\", {\n          style: t.tooltip.tableCellValue,\n          children: e.data[n + \"Formatted\"]\n        }, \"value\")];\n      })\n    });\n  }),\n  $ = {\n    curve: \"linear\",\n    xScale: {\n      type: \"point\"\n    },\n    yScale: {\n      type: \"linear\",\n      min: 0,\n      max: \"auto\"\n    },\n    layers: [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: !0,\n    enableGridY: !0,\n    enablePoints: !0,\n    pointSize: 6,\n    pointColor: {\n      from: \"color\"\n    },\n    pointBorderWidth: 0,\n    pointBorderColor: {\n      theme: \"background\"\n    },\n    enablePointLabel: !1,\n    pointLabel: \"yFormatted\",\n    colors: {\n      scheme: \"nivo\"\n    },\n    enableArea: !1,\n    areaBaselineValue: 0,\n    areaOpacity: .2,\n    areaBlendMode: \"normal\",\n    lineWidth: 2,\n    legends: [],\n    isInteractive: !0,\n    tooltip: U,\n    enableSlices: !1,\n    debugSlices: !1,\n    sliceTooltip: Z,\n    debugMesh: !1,\n    enableCrosshair: !0,\n    crosshairType: \"bottom-left\"\n  },\n  _ = Q({}, $, {\n    enablePointLabel: !1,\n    useMesh: !1,\n    enableTouchCrosshair: !1,\n    animate: !0,\n    motionConfig: \"gentle\",\n    defs: [],\n    fill: [],\n    role: \"img\"\n  }),\n  ee = Q({}, $, {\n    pixelRatio: \"undefined\" != typeof window && window.devicePixelRatio || 1\n  }),\n  oe = function (e) {\n    var i = e.curve;\n    return o(function () {\n      return R().defined(function (e) {\n        return null !== e.x && null !== e.y;\n      }).x(function (e) {\n        return e.x;\n      }).y(function (e) {\n        return e.y;\n      }).curve(u(i));\n    }, [i]);\n  },\n  ie = function (e) {\n    var i = e.curve,\n      t = e.yScale,\n      n = e.areaBaselineValue;\n    return o(function () {\n      return I().defined(function (e) {\n        return null !== e.x && null !== e.y;\n      }).x(function (e) {\n        return e.x;\n      }).y1(function (e) {\n        return e.y;\n      }).curve(u(i)).y0(t(n));\n    }, [i, t, n]);\n  },\n  te = function (e) {\n    var i = e.componentId,\n      t = e.enableSlices,\n      n = e.points,\n      r = e.width,\n      a = e.height;\n    return o(function () {\n      if (!1 === t) return [];\n      if (\"x\" === t) {\n        var e = new Map();\n        return n.forEach(function (o) {\n          null !== o.data.x && null !== o.data.y && (e.has(o.x) ? e.get(o.x).push(o) : e.set(o.x, [o]));\n        }), Array.from(e.entries()).sort(function (e, o) {\n          return e[0] - o[0];\n        }).map(function (e, o, t) {\n          var n,\n            l,\n            s = e[0],\n            c = e[1],\n            u = t[o - 1],\n            d = t[o + 1];\n          return n = u ? s - (s - u[0]) / 2 : s, l = d ? s - n + (d[0] - s) / 2 : r - n, {\n            id: \"slice:\" + i + \":\" + s,\n            x0: n,\n            x: s,\n            y0: 0,\n            y: 0,\n            width: l,\n            height: a,\n            points: c.reverse()\n          };\n        });\n      }\n      if (\"y\" === t) {\n        var o = new Map();\n        return n.forEach(function (e) {\n          null !== e.data.x && null !== e.data.y && (o.has(e.y) ? o.get(e.y).push(e) : o.set(e.y, [e]));\n        }), Array.from(o.entries()).sort(function (e, o) {\n          return e[0] - o[0];\n        }).map(function (e, o, i) {\n          var t,\n            n,\n            l = e[0],\n            s = e[1],\n            c = i[o - 1],\n            u = i[o + 1];\n          return t = c ? l - (l - c[0]) / 2 : l, n = u ? l - t + (u[0] - l) / 2 : a - t, {\n            id: l,\n            x0: 0,\n            x: 0,\n            y0: t,\n            y: l,\n            width: r,\n            height: n,\n            points: s.reverse()\n          };\n        });\n      }\n    }, [i, t, a, n, r]);\n  },\n  ne = \"line\",\n  re = function (e) {\n    var n = e.data,\n      r = e.xScale,\n      a = void 0 === r ? _.xScale : r,\n      l = e.xFormat,\n      s = e.yScale,\n      u = void 0 === s ? _.yScale : s,\n      h = e.yFormat,\n      f = e.width,\n      v = e.height,\n      p = e.colors,\n      m = void 0 === p ? _.colors : p,\n      g = e.curve,\n      y = void 0 === g ? _.curve : g,\n      x = e.areaBaselineValue,\n      b = void 0 === x ? _.areaBaselineValue : x,\n      S = e.pointColor,\n      M = void 0 === S ? _.pointColor : S,\n      C = e.pointBorderColor,\n      k = void 0 === C ? _.pointBorderColor : C,\n      B = e.enableSlices,\n      W = void 0 === B ? _.enableSlicesTooltip : B,\n      E = i(H(ne))[0],\n      L = d(l),\n      G = d(h),\n      P = w(m, \"id\"),\n      F = c(),\n      O = T(M, F),\n      V = T(k, F),\n      Y = i([]),\n      R = Y[0],\n      I = Y[1],\n      X = o(function () {\n        return A(n.filter(function (e) {\n          return -1 === R.indexOf(e.id);\n        }), a, u, f, v);\n      }, [n, R, a, u, f, v]),\n      z = X.xScale,\n      j = X.yScale,\n      D = X.series,\n      q = o(function () {\n        var e = n.map(function (e) {\n            return {\n              id: e.id,\n              label: e.id,\n              color: P(e)\n            };\n          }),\n          o = e.map(function (e) {\n            return Q({}, D.find(function (o) {\n              return o.id === e.id;\n            }), {\n              color: e.color\n            });\n          }).filter(function (e) {\n            return Boolean(e.id);\n          });\n        return {\n          legendData: e.map(function (e) {\n            return Q({}, e, {\n              hidden: !o.find(function (o) {\n                return o.id === e.id;\n              })\n            });\n          }).reverse(),\n          series: o\n        };\n      }, [n, D, P]),\n      J = q.legendData,\n      K = q.series,\n      N = t(function (e) {\n        I(function (o) {\n          return o.indexOf(e) > -1 ? o.filter(function (o) {\n            return o !== e;\n          }) : [].concat(o, [e]);\n        });\n      }, []),\n      U = function (e) {\n        var i = e.series,\n          t = e.getPointColor,\n          n = e.getPointBorderColor,\n          r = e.formatX,\n          a = e.formatY;\n        return o(function () {\n          return i.reduce(function (e, o) {\n            return [].concat(e, o.data.filter(function (e) {\n              return null !== e.position.x && null !== e.position.y;\n            }).map(function (i, l) {\n              var s = {\n                id: o.id + \".\" + l,\n                index: e.length + l,\n                serieId: o.id,\n                serieColor: o.color,\n                x: i.position.x,\n                y: i.position.y\n              };\n              return s.color = t(o), s.borderColor = n(s), s.data = Q({}, i.data, {\n                xFormatted: r(i.data.x),\n                yFormatted: a(i.data.y)\n              }), s;\n            }));\n          }, []);\n        }, [i, t, n, r, a]);\n      }({\n        series: K,\n        getPointColor: O,\n        getPointBorderColor: V,\n        formatX: L,\n        formatY: G\n      }),\n      Z = te({\n        componentId: E,\n        enableSlices: W,\n        points: U,\n        width: f,\n        height: v\n      });\n    return {\n      legendData: J,\n      toggleSerie: N,\n      lineGenerator: oe({\n        curve: y\n      }),\n      areaGenerator: ie({\n        curve: y,\n        yScale: j,\n        areaBaselineValue: b\n      }),\n      getColor: P,\n      series: K,\n      xScale: z,\n      yScale: j,\n      slices: Z,\n      points: U\n    };\n  },\n  ae = function (e) {\n    var o = e.areaBlendMode,\n      i = e.areaOpacity,\n      t = e.color,\n      n = e.fill,\n      r = e.path,\n      a = h(),\n      l = a.animate,\n      s = a.config,\n      c = f(r),\n      u = j({\n        color: t,\n        config: s,\n        immediate: !l\n      });\n    return X(D.path, {\n      d: c,\n      fill: n || u.color,\n      fillOpacity: i,\n      strokeWidth: 0,\n      style: {\n        mixBlendMode: o\n      }\n    });\n  },\n  le = e(function (e) {\n    var o = e.areaGenerator,\n      i = e.areaOpacity,\n      t = e.areaBlendMode,\n      n = e.lines.slice(0).reverse();\n    return X(\"g\", {\n      children: n.map(function (e) {\n        return X(ae, Q({\n          path: o(e.data.map(function (e) {\n            return e.position;\n          }))\n        }, Q({\n          areaOpacity: i,\n          areaBlendMode: t\n        }, e)), e.id);\n      })\n    });\n  }),\n  se = e(function (e) {\n    var i = e.lineGenerator,\n      t = e.points,\n      n = e.color,\n      r = e.thickness,\n      a = o(function () {\n        return i(t);\n      }, [i, t]),\n      l = f(a);\n    return X(D.path, {\n      d: l,\n      fill: \"none\",\n      strokeWidth: r,\n      stroke: n\n    });\n  }),\n  ce = e(function (e) {\n    var o = e.lines,\n      i = e.lineGenerator,\n      t = e.lineWidth;\n    return o.slice(0).reverse().map(function (e) {\n      var o = e.id,\n        n = e.data,\n        r = e.color;\n      return X(se, {\n        id: o,\n        points: n.map(function (e) {\n          return e.position;\n        }),\n        lineGenerator: i,\n        color: r,\n        thickness: t\n      }, o);\n    });\n  }),\n  ue = e(function (e) {\n    var o = e.slice,\n      i = e.slices,\n      r = e.axis,\n      a = e.debug,\n      l = e.tooltip,\n      s = e.isCurrent,\n      c = e.setCurrent,\n      u = e.onMouseEnter,\n      d = e.onMouseMove,\n      h = e.onMouseLeave,\n      f = e.onClick,\n      v = e.onTouchStart,\n      p = e.onTouchMove,\n      m = e.onTouchEnd,\n      g = V(),\n      y = g.showTooltipFromEvent,\n      x = g.hideTooltip,\n      b = t(function (e) {\n        y(n(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), c(o), u && u(o, e);\n      }, [y, l, o, r, c, u]),\n      S = t(function (e) {\n        y(n(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), d && d(o, e);\n      }, [y, l, o, r, d]),\n      M = t(function (e) {\n        x(), c(null), h && h(o, e);\n      }, [x, c, h, o]),\n      C = t(function (e) {\n        f && f(o, e);\n      }, [o, f]),\n      w = t(function (e) {\n        y(n(l, {\n          slice: o,\n          axis: r\n        }), e, \"right\"), c(o), v && v(o, e);\n      }, [r, v, c, y, o, l]),\n      T = t(function (e) {\n        var t = e.touches[0],\n          a = document.elementFromPoint(t.clientX, t.clientY),\n          s = null == a ? void 0 : a.getAttribute(\"data-ref\");\n        if (s) {\n          var u = i.find(function (e) {\n            return e.id === s;\n          });\n          u && (y(n(l, {\n            slice: u,\n            axis: r\n          }), e, \"right\"), c(u));\n        }\n        p && p(o, e);\n      }, [r, p, c, y, o, i, l]),\n      k = t(function (e) {\n        x(), c(null), m && m(o, e);\n      }, [x, c, m, o]);\n    return X(\"rect\", {\n      x: o.x0,\n      y: o.y0,\n      width: o.width,\n      height: o.height,\n      stroke: \"red\",\n      strokeWidth: a ? 1 : 0,\n      strokeOpacity: .75,\n      fill: \"red\",\n      fillOpacity: s && a ? .35 : 0,\n      onMouseEnter: b,\n      onMouseMove: S,\n      onMouseLeave: M,\n      onClick: C,\n      onTouchStart: w,\n      onTouchMove: T,\n      onTouchEnd: k,\n      \"data-ref\": o.id\n    });\n  }),\n  de = e(function (e) {\n    var o = e.slices,\n      i = e.axis,\n      t = e.debug,\n      n = e.height,\n      r = e.tooltip,\n      a = e.current,\n      l = e.setCurrent,\n      s = e.onMouseEnter,\n      c = e.onMouseMove,\n      u = e.onMouseLeave,\n      d = e.onClick,\n      h = e.onTouchStart,\n      f = e.onTouchMove,\n      v = e.onTouchEnd;\n    return o.map(function (e) {\n      return X(ue, {\n        slice: e,\n        slices: o,\n        axis: i,\n        debug: t,\n        height: n,\n        tooltip: r,\n        setCurrent: l,\n        isCurrent: null !== a && a.id === e.id,\n        onMouseEnter: s,\n        onMouseMove: c,\n        onMouseLeave: u,\n        onClick: d,\n        onTouchStart: h,\n        onTouchMove: f,\n        onTouchEnd: v\n      }, e.id);\n    });\n  }),\n  he = e(function (e) {\n    var o = e.points,\n      i = e.symbol,\n      t = e.size,\n      n = e.borderWidth,\n      r = e.enableLabel,\n      a = e.label,\n      l = e.labelYOffset,\n      s = c(),\n      u = v(a),\n      d = o.slice(0).reverse().map(function (e) {\n        return {\n          id: e.id,\n          x: e.x,\n          y: e.y,\n          datum: e.data,\n          fill: e.color,\n          stroke: e.borderColor,\n          label: r ? u(e) : null\n        };\n      });\n    return X(\"g\", {\n      children: d.map(function (e) {\n        return X(p, {\n          x: e.x,\n          y: e.y,\n          datum: e.datum,\n          symbol: i,\n          size: t,\n          color: e.fill,\n          borderWidth: n,\n          borderColor: e.stroke,\n          label: e.label,\n          labelYOffset: l,\n          theme: s\n        }, e.id);\n      })\n    });\n  }),\n  fe = e(function (e) {\n    var o = e.points,\n      i = e.width,\n      r = e.height,\n      a = e.margin,\n      l = e.setCurrent,\n      s = e.onMouseEnter,\n      c = e.onMouseMove,\n      u = e.onMouseLeave,\n      d = e.onClick,\n      h = e.onTouchStart,\n      f = e.onTouchMove,\n      v = e.onTouchEnd,\n      p = e.tooltip,\n      m = e.debug,\n      g = e.enableTouchCrosshair,\n      y = V(),\n      x = y.showTooltipAt,\n      b = y.hideTooltip,\n      S = t(function (e, o) {\n        x(n(p, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), s && s(e, o);\n      }, [x, p, s, a]),\n      M = t(function (e, o) {\n        x(n(p, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), c && c(e, o);\n      }, [x, p, a.left, a.top, c]),\n      C = t(function (e, o) {\n        b(), u && u(e, o);\n      }, [b, u]),\n      w = t(function (e, o) {\n        d && d(e, o);\n      }, [d]),\n      T = t(function (e, o) {\n        x(n(p, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), h && h(e, o);\n      }, [a.left, a.top, h, x, p]),\n      k = t(function (e, o) {\n        x(n(p, {\n          point: e\n        }), [e.x + a.left, e.y + a.top], \"top\"), f && f(e, o);\n      }, [a.left, a.top, f, x, p]),\n      B = t(function (e, o) {\n        b(), v && v(e, o);\n      }, [v, b]);\n    return X(q, {\n      nodes: o,\n      width: i,\n      height: r,\n      setCurrent: l,\n      onMouseEnter: S,\n      onMouseMove: M,\n      onMouseLeave: C,\n      onClick: w,\n      onTouchStart: T,\n      onTouchMove: k,\n      onTouchEnd: B,\n      enableTouchCrosshair: g,\n      debug: m\n    });\n  }),\n  ve = m(function (e) {\n    var o = e.data,\n      t = e.xScale,\n      n = void 0 === t ? {\n        type: \"point\"\n      } : t,\n      a = e.xFormat,\n      l = e.yScale,\n      s = void 0 === l ? {\n        type: \"linear\",\n        min: 0,\n        max: \"auto\"\n      } : l,\n      u = e.yFormat,\n      d = e.layers,\n      h = void 0 === d ? [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"] : d,\n      f = e.curve,\n      v = void 0 === f ? \"linear\" : f,\n      p = e.areaBaselineValue,\n      m = void 0 === p ? 0 : p,\n      S = e.colors,\n      M = void 0 === S ? {\n        scheme: \"nivo\"\n      } : S,\n      C = e.margin,\n      w = e.width,\n      W = e.height,\n      E = e.axisTop,\n      G = e.axisRight,\n      P = e.axisBottom,\n      F = void 0 === P ? {} : P,\n      O = e.axisLeft,\n      V = void 0 === O ? {} : O,\n      R = e.enableGridX,\n      I = void 0 === R || R,\n      A = e.enableGridY,\n      H = void 0 === A || A,\n      z = e.gridXValues,\n      j = e.gridYValues,\n      D = e.lineWidth,\n      q = void 0 === D ? 2 : D,\n      J = e.enableArea,\n      K = void 0 !== J && J,\n      N = e.areaOpacity,\n      $ = void 0 === N ? .2 : N,\n      _ = e.areaBlendMode,\n      ee = void 0 === _ ? \"normal\" : _,\n      oe = e.enablePoints,\n      ie = void 0 === oe || oe,\n      te = e.pointSymbol,\n      ne = e.pointSize,\n      ae = void 0 === ne ? 6 : ne,\n      se = e.pointColor,\n      ue = void 0 === se ? {\n        from: \"color\"\n      } : se,\n      ve = e.pointBorderWidth,\n      pe = void 0 === ve ? 0 : ve,\n      me = e.pointBorderColor,\n      ge = void 0 === me ? {\n        theme: \"background\"\n      } : me,\n      ye = e.enablePointLabel,\n      xe = void 0 !== ye && ye,\n      be = e.pointLabel,\n      Se = void 0 === be ? \"data.yFormatted\" : be,\n      Me = e.pointLabelYOffset,\n      Ce = e.defs,\n      we = void 0 === Ce ? [] : Ce,\n      Te = e.fill,\n      ke = void 0 === Te ? [] : Te,\n      Be = e.markers,\n      We = e.legends,\n      Ee = void 0 === We ? [] : We,\n      Le = e.isInteractive,\n      Ge = void 0 === Le || Le,\n      Pe = e.useMesh,\n      Fe = void 0 !== Pe && Pe,\n      Oe = e.debugMesh,\n      Ve = void 0 !== Oe && Oe,\n      Ye = e.onMouseEnter,\n      Re = e.onMouseMove,\n      Ie = e.onMouseLeave,\n      Ae = e.onClick,\n      He = e.onTouchStart,\n      Xe = e.onTouchMove,\n      ze = e.onTouchEnd,\n      je = e.tooltip,\n      De = void 0 === je ? U : je,\n      qe = e.enableSlices,\n      Je = void 0 !== qe && qe,\n      Ke = e.debugSlices,\n      Ne = void 0 !== Ke && Ke,\n      Qe = e.sliceTooltip,\n      Ue = void 0 === Qe ? Z : Qe,\n      Ze = e.enableCrosshair,\n      $e = void 0 === Ze || Ze,\n      _e = e.crosshairType,\n      eo = void 0 === _e ? \"bottom-left\" : _e,\n      oo = e.enableTouchCrosshair,\n      io = void 0 !== oo && oo,\n      to = e.role,\n      no = void 0 === to ? \"img\" : to,\n      ro = g(w, W, C),\n      ao = ro.margin,\n      lo = ro.innerWidth,\n      so = ro.innerHeight,\n      co = ro.outerWidth,\n      uo = ro.outerHeight,\n      ho = re({\n        data: o,\n        xScale: n,\n        xFormat: a,\n        yScale: s,\n        yFormat: u,\n        width: lo,\n        height: so,\n        colors: M,\n        curve: v,\n        areaBaselineValue: m,\n        pointColor: ue,\n        pointBorderColor: ge,\n        enableSlices: Je\n      }),\n      fo = ho.legendData,\n      vo = ho.toggleSerie,\n      po = ho.lineGenerator,\n      mo = ho.areaGenerator,\n      go = ho.series,\n      yo = ho.xScale,\n      xo = ho.yScale,\n      bo = ho.slices,\n      So = ho.points,\n      Mo = c(),\n      Co = T(ue, Mo),\n      wo = T(ge, Mo),\n      To = i(null),\n      ko = To[0],\n      Bo = To[1],\n      Wo = i(null),\n      Eo = Wo[0],\n      Lo = Wo[1],\n      Go = {\n        grid: X(k, {\n          theme: Mo,\n          width: lo,\n          height: so,\n          xScale: I ? yo : null,\n          yScale: H ? xo : null,\n          xValues: z,\n          yValues: j\n        }, \"grid\"),\n        markers: X(y, {\n          markers: Be,\n          width: lo,\n          height: so,\n          xScale: yo,\n          yScale: xo,\n          theme: Mo\n        }, \"markers\"),\n        axes: X(B, {\n          xScale: yo,\n          yScale: xo,\n          width: lo,\n          height: so,\n          theme: Mo,\n          top: E,\n          right: G,\n          bottom: F,\n          left: V\n        }, \"axes\"),\n        areas: null,\n        lines: X(ce, {\n          lines: go,\n          lineGenerator: po,\n          lineWidth: q\n        }, \"lines\"),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: Ee.map(function (e, o) {\n          return X(L, Q({}, e, {\n            containerWidth: lo,\n            containerHeight: so,\n            data: e.data || fo,\n            theme: Mo,\n            toggleSerie: e.toggleSerie ? vo : void 0\n          }), \"legend.\" + o);\n        })\n      },\n      Po = x(we, go, ke);\n    return K && (Go.areas = X(le, {\n      areaGenerator: mo,\n      areaOpacity: $,\n      areaBlendMode: ee,\n      lines: go\n    }, \"areas\")), Ge && !1 !== Je && (Go.slices = X(de, {\n      slices: bo,\n      axis: Je,\n      debug: Ne,\n      height: so,\n      tooltip: Ue,\n      current: Eo,\n      setCurrent: Lo,\n      onMouseEnter: Ye,\n      onMouseMove: Re,\n      onMouseLeave: Ie,\n      onClick: Ae,\n      onTouchStart: He,\n      onTouchMove: Xe,\n      onTouchEnd: ze\n    }, \"slices\")), ie && (Go.points = X(he, {\n      points: So,\n      symbol: te,\n      size: ae,\n      color: Co,\n      borderWidth: pe,\n      borderColor: wo,\n      enableLabel: xe,\n      label: Se,\n      labelYOffset: Me\n    }, \"points\")), Ge && $e && (null !== ko && (Go.crosshair = X(Y, {\n      width: lo,\n      height: so,\n      x: ko.x,\n      y: ko.y,\n      type: eo\n    }, \"crosshair\")), null !== Eo && (Go.crosshair = X(Y, {\n      width: lo,\n      height: so,\n      x: Eo.x,\n      y: Eo.y,\n      type: Je\n    }, \"crosshair\"))), Ge && Fe && !1 === Je && (Go.mesh = X(fe, {\n      points: So,\n      width: lo,\n      height: so,\n      margin: ao,\n      current: ko,\n      setCurrent: Bo,\n      onMouseEnter: Ye,\n      onMouseMove: Re,\n      onMouseLeave: Ie,\n      onClick: Ae,\n      onTouchStart: He,\n      onTouchMove: Xe,\n      onTouchEnd: ze,\n      tooltip: De,\n      enableTouchCrosshair: io,\n      debug: Ve\n    }, \"mesh\")), X(b, {\n      defs: Po,\n      width: co,\n      height: uo,\n      margin: ao,\n      role: no,\n      children: h.map(function (o, i) {\n        return \"function\" == typeof o ? X(r, {\n          children: o(Q({}, e, {\n            innerWidth: lo,\n            innerHeight: so,\n            series: go,\n            slices: bo,\n            points: So,\n            xScale: yo,\n            yScale: xo,\n            lineGenerator: po,\n            areaGenerator: mo,\n            currentPoint: ko,\n            setCurrentPoint: Bo,\n            currentSlice: Eo,\n            setCurrentSlice: Lo\n          }))\n        }, i) : Go[o];\n      })\n    });\n  }),\n  pe = function (e) {\n    return X(S, {\n      children: function (o) {\n        var i = o.width,\n          t = o.height;\n        return X(ve, Q({\n          width: i,\n          height: t\n        }, e));\n      }\n    });\n  },\n  me = m(function (e) {\n    var o = l(null),\n      r = e.width,\n      a = e.height,\n      u = e.margin,\n      d = e.pixelRatio,\n      h = void 0 === d ? \"undefined\" != typeof window && window.devicePixelRatio || 1 : d,\n      f = e.data,\n      v = e.xScale,\n      p = void 0 === v ? {\n        type: \"point\"\n      } : v,\n      m = e.xFormat,\n      y = e.yScale,\n      x = void 0 === y ? {\n        type: \"linear\",\n        min: 0,\n        max: \"auto\"\n      } : y,\n      b = e.yFormat,\n      S = e.curve,\n      w = void 0 === S ? \"linear\" : S,\n      T = e.layers,\n      k = void 0 === T ? [\"grid\", \"markers\", \"axes\", \"areas\", \"crosshair\", \"lines\", \"points\", \"slices\", \"mesh\", \"legends\"] : T,\n      B = e.colors,\n      L = void 0 === B ? {\n        scheme: \"nivo\"\n      } : B,\n      P = e.lineWidth,\n      F = void 0 === P ? 2 : P,\n      O = e.enableArea,\n      Y = void 0 !== O && O,\n      R = e.areaBaselineValue,\n      I = void 0 === R ? 0 : R,\n      A = e.areaOpacity,\n      H = void 0 === A ? .2 : A,\n      z = e.enablePoints,\n      j = void 0 === z || z,\n      D = e.pointSize,\n      q = void 0 === D ? 6 : D,\n      Z = e.pointColor,\n      $ = void 0 === Z ? {\n        from: \"color\"\n      } : Z,\n      _ = e.pointBorderWidth,\n      ee = void 0 === _ ? 0 : _,\n      oe = e.pointBorderColor,\n      ie = void 0 === oe ? {\n        theme: \"background\"\n      } : oe,\n      te = e.enableGridX,\n      ne = void 0 === te || te,\n      ae = e.gridXValues,\n      le = e.enableGridY,\n      se = void 0 === le || le,\n      ce = e.gridYValues,\n      ue = e.axisTop,\n      de = e.axisRight,\n      he = e.axisBottom,\n      fe = void 0 === he ? {} : he,\n      ve = e.axisLeft,\n      pe = void 0 === ve ? {} : ve,\n      me = e.legends,\n      ge = void 0 === me ? [] : me,\n      ye = e.isInteractive,\n      xe = void 0 === ye || ye,\n      be = e.debugMesh,\n      Se = void 0 !== be && be,\n      Me = e.onMouseLeave,\n      Ce = e.onClick,\n      we = e.tooltip,\n      Te = void 0 === we ? U : we,\n      ke = e.canvasRef,\n      Be = g(r, a, u),\n      We = Be.margin,\n      Ee = Be.innerWidth,\n      Le = Be.innerHeight,\n      Ge = Be.outerWidth,\n      Pe = Be.outerHeight,\n      Fe = c(),\n      Oe = i(null),\n      Ve = Oe[0],\n      Ye = Oe[1],\n      Re = re({\n        data: f,\n        xScale: p,\n        xFormat: m,\n        yScale: x,\n        yFormat: b,\n        width: Ee,\n        height: Le,\n        colors: L,\n        curve: w,\n        areaBaselineValue: I,\n        pointColor: $,\n        pointBorderColor: ie\n      }),\n      Ie = Re.lineGenerator,\n      Ae = Re.areaGenerator,\n      He = Re.series,\n      Xe = Re.xScale,\n      ze = Re.yScale,\n      je = Re.points,\n      De = J({\n        points: je,\n        width: Ee,\n        height: Le,\n        debug: Se\n      }),\n      qe = De.delaunay,\n      Je = De.voronoi;\n    s(function () {\n      ke && (ke.current = o.current), o.current.width = Ge * h, o.current.height = Pe * h;\n      var e = o.current.getContext(\"2d\");\n      e.scale(h, h), e.fillStyle = Fe.background, e.fillRect(0, 0, Ge, Pe), e.translate(We.left, We.top), k.forEach(function (o) {\n        if (\"function\" == typeof o && o({\n          ctx: e,\n          innerWidth: Ee,\n          innerHeight: Le,\n          series: He,\n          points: je,\n          xScale: Xe,\n          yScale: ze,\n          lineWidth: F,\n          lineGenerator: Ie,\n          areaGenerator: Ae,\n          currentPoint: Ve,\n          setCurrentPoint: Ye\n        }), \"grid\" === o && Fe.grid.line.strokeWidth > 0 && (e.lineWidth = Fe.grid.line.strokeWidth, e.strokeStyle = Fe.grid.line.stroke, ne && W(e, {\n          width: Ee,\n          height: Le,\n          scale: Xe,\n          axis: \"x\",\n          values: ae\n        }), se && W(e, {\n          width: Ee,\n          height: Le,\n          scale: ze,\n          axis: \"y\",\n          values: ce\n        })), \"axes\" === o && E(e, {\n          xScale: Xe,\n          yScale: ze,\n          width: Ee,\n          height: Le,\n          top: ue,\n          right: de,\n          bottom: fe,\n          left: pe,\n          theme: Fe\n        }), \"areas\" === o && !0 === Y) {\n          e.save(), e.globalAlpha = H, Ae.context(e);\n          for (var i = He.length - 1; i >= 0; i--) e.fillStyle = He[i].color, e.beginPath(), Ae(He[i].data.map(function (e) {\n            return e.position;\n          })), e.fill();\n          e.restore();\n        }\n        if (\"lines\" === o && (Ie.context(e), He.forEach(function (o) {\n          e.strokeStyle = o.color, e.lineWidth = F, e.beginPath(), Ie(o.data.map(function (e) {\n            return e.position;\n          })), e.stroke();\n        })), \"points\" === o && !0 === j && q > 0 && je.forEach(function (o) {\n          e.fillStyle = o.color, e.beginPath(), e.arc(o.x, o.y, q / 2, 0, 2 * Math.PI), e.fill(), ee > 0 && (e.strokeStyle = o.borderColor, e.lineWidth = ee, e.stroke());\n        }), \"mesh\" === o && !0 === Se && (K(e, Je), Ve && N(e, Je, Ve.index)), \"legends\" === o) {\n          var t = He.map(function (e) {\n            return {\n              id: e.id,\n              label: e.id,\n              color: e.color\n            };\n          }).reverse();\n          ge.forEach(function (o) {\n            G(e, Q({}, o, {\n              data: o.data || t,\n              containerWidth: Ee,\n              containerHeight: Le,\n              theme: Fe\n            }));\n          });\n        }\n      });\n    }, [o, Ge, Pe, k, Fe, Ie, He, Xe, ze, ne, ae, se, ce, ue, de, fe, pe, ge, je, j, q, Ve]);\n    var Ke = t(function (e) {\n        var i = M(o.current, e),\n          t = i[0],\n          n = i[1];\n        if (!C(We.left, We.top, Ee, Le, t, n)) return null;\n        var r = qe.find(t - We.left, n - We.top);\n        return je[r];\n      }, [o, We, Ee, Le, qe]),\n      Ne = V(),\n      Qe = Ne.showTooltipFromEvent,\n      Ue = Ne.hideTooltip,\n      Ze = t(function (e) {\n        var o = Ke(e);\n        Ye(o), o ? Qe(n(Te, {\n          point: o\n        }), e) : Ue();\n      }, [Ke, Ye, Qe, Ue, Te]),\n      $e = t(function (e) {\n        Ue(), Ye(null), Ve && Me && Me(Ve, e);\n      }, [Ue, Ye, Me]),\n      _e = t(function (e) {\n        if (Ce) {\n          var o = Ke(e);\n          o && Ce(o, e);\n        }\n      }, [Ke, Ce]);\n    return X(\"canvas\", {\n      ref: o,\n      width: Ge * h,\n      height: Pe * h,\n      style: {\n        width: Ge,\n        height: Pe,\n        cursor: xe ? \"auto\" : \"normal\"\n      },\n      onMouseEnter: xe ? Ze : void 0,\n      onMouseMove: xe ? Ze : void 0,\n      onMouseLeave: xe ? $e : void 0,\n      onClick: xe ? _e : void 0\n    });\n  }),\n  ge = a(function (e, o) {\n    return X(me, Q({}, e, {\n      canvasRef: o\n    }));\n  }),\n  ye = a(function (e, o) {\n    return X(S, {\n      children: function (i) {\n        var t = i.width,\n          n = i.height;\n        return X(ge, Q({\n          width: t,\n          height: n\n        }, e, {\n          ref: o\n        }));\n      }\n    });\n  });\nexport { ne as LINE_UNIQUE_ID_PREFIX, ve as Line, ge as LineCanvas, ee as LineCanvasDefaultProps, _ as LineDefaultProps, pe as ResponsiveLine, ye as ResponsiveLineCanvas, ie as useAreaGenerator, re as useLine, oe as useLineGenerator, te as useSlices };","map":{"version":3,"names":["U","e","o","point","X","P","id","z","children","data","xFormatted","yFormatted","enableChip","color","serieColor","Z","slice","i","axis","t","c","n","F","rows","points","map","O","style","tooltip","chip","serieId","tableCellValue","$","curve","xScale","type","yScale","min","max","layers","axisBottom","axisLeft","enableGridX","enableGridY","enablePoints","pointSize","pointColor","from","pointBorderWidth","pointBorderColor","theme","enablePointLabel","pointLabel","colors","scheme","enableArea","areaBaselineValue","areaOpacity","areaBlendMode","lineWidth","legends","isInteractive","enableSlices","debugSlices","sliceTooltip","debugMesh","enableCrosshair","crosshairType","_","Q","useMesh","enableTouchCrosshair","animate","motionConfig","defs","fill","role","ee","pixelRatio","window","devicePixelRatio","oe","useLineGenerator","R","defined","x","y","u","ie","useAreaGenerator","I","y1","y0","te","useSlices","componentId","r","width","a","height","Map","forEach","has","get","push","set","Array","entries","sort","l","s","d","x0","reverse","ne","re","useLine","xFormat","h","yFormat","f","v","p","m","g","b","S","M","C","k","B","W","enableSlicesTooltip","E","H","L","G","w","T","V","Y","A","filter","indexOf","j","D","series","q","label","find","Boolean","legendData","hidden","J","K","N","concat","getPointColor","getPointBorderColor","formatX","formatY","reduce","position","index","length","borderColor","toggleSerie","lineGenerator","areaGenerator","getColor","slices","ae","AreaPath","path","config","immediate","fillOpacity","strokeWidth","mixBlendMode","le","lines","se","thickness","stroke","ce","ue","debug","isCurrent","setCurrent","onMouseEnter","onMouseMove","onMouseLeave","onClick","onTouchStart","onTouchMove","onTouchEnd","showTooltipFromEvent","hideTooltip","touches","document","elementFromPoint","clientX","clientY","getAttribute","strokeOpacity","de","current","he","symbol","size","borderWidth","enableLabel","labelYOffset","datum","fe","margin","showTooltipAt","left","top","nodes","ve","axisTop","axisRight","gridXValues","gridYValues","pointSymbol","pe","me","ge","ye","xe","be","Se","Me","pointLabelYOffset","Ce","we","Te","ke","Be","markers","We","Ee","Le","Ge","Pe","Fe","Oe","Ve","Ye","Re","Ie","Ae","He","Xe","ze","je","De","qe","Je","Ke","Ne","Qe","Ue","Ze","$e","_e","eo","oo","io","to","no","ro","ao","lo","innerWidth","so","innerHeight","co","outerWidth","uo","outerHeight","ho","fo","vo","po","mo","go","yo","xo","bo","So","Mo","Co","wo","To","ko","Bo","Wo","Eo","Lo","Go","grid","xValues","yValues","axes","right","bottom","areas","crosshair","mesh","containerWidth","containerHeight","Po","currentPoint","setCurrentPoint","currentSlice","setCurrentSlice","ResponsiveLine","canvasRef","delaunay","voronoi","getContext","scale","fillStyle","background","fillRect","translate","ctx","line","strokeStyle","values","save","globalAlpha","context","beginPath","restore","arc","Math","PI","ref","cursor","LINE_UNIQUE_ID_PREFIX","Line","LineCanvas","LineCanvasDefaultProps","LineDefaultProps","ResponsiveLineCanvas"],"sources":["/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/PointTooltip.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/SliceTooltip.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/props.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/hooks.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/Areas.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/LinesItem.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/Lines.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/SlicesItem.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/Slices.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/Points.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/Mesh.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/Line.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/ResponsiveLine.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/LineCanvas.js","/Users/wonseok/Desktop/react/new/node_modules/@nivo/line/src/ResponsiveLineCanvas.js"],"sourcesContent":["import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nconst LinePointTooltip = ({ point }) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.serieColor}\n        />\n    )\n}\n\nexport default memo(LinePointTooltip)\n","import { memo } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\n\nconst SliceTooltip = ({ slice, axis }) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.serieColor} style={theme.tooltip.chip} />,\n                point.serieId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport default memo(SliceTooltip)\n","import PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst commonDefaultProps = {\n    curve: 'linear',\n\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: true,\n    enableGridY: true,\n\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enablePointLabel: false,\n    pointLabel: 'yFormatted',\n\n    colors: { scheme: 'nivo' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    areaBlendMode: 'normal',\n    lineWidth: 2,\n\n    legends: [],\n\n    isInteractive: true,\n    tooltip: PointTooltip,\n    enableSlices: false,\n    debugSlices: false,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n}\n\nexport const LineDefaultProps = {\n    ...commonDefaultProps,\n    enablePointLabel: false,\n    useMesh: false,\n    enableTouchCrosshair: false,\n    animate: true,\n    motionConfig: 'gentle',\n    defs: [],\n    fill: [],\n    role: 'img',\n}\n\nexport const LineCanvasDefaultProps = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n","import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport { curveFromProp, useTheme, useValueFormatter } from '@nivo/core'\nimport { useOrdinalColorScale, useInheritedColor } from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport uniqueId from 'lodash/uniqueId'\nimport { LineDefaultProps } from './props'\n\nexport const useLineGenerator = ({ curve }) => {\n    return useMemo(\n        () =>\n            line()\n                .defined(d => d.x !== null && d.y !== null)\n                .x(d => d.x)\n                .y(d => d.y)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n}\n\nexport const useAreaGenerator = ({ curve, yScale, areaBaselineValue }) => {\n    return useMemo(() => {\n        return area()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nconst usePoints = ({ series, getPointColor, getPointBorderColor, formatX, formatY }) => {\n    return useMemo(() => {\n        return series.reduce((acc, serie) => {\n            return [\n                ...acc,\n                ...serie.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, i) => {\n                        const point = {\n                            id: `${serie.id}.${i}`,\n                            index: acc.length + i,\n                            serieId: serie.id,\n                            serieColor: serie.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                        }\n                        point.color = getPointColor(serie)\n                        point.borderColor = getPointBorderColor(point)\n                        point.data = {\n                            ...datum.data,\n                            xFormatted: formatX(datum.data.x),\n                            yFormatted: formatY(datum.data.y),\n                        }\n\n                        return point\n                    }),\n            ]\n        }, [])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = ({ componentId, enableSlices, points, width, height }) => {\n    return useMemo(() => {\n        if (enableSlices === false) return []\n\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    }\n                })\n        }\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = ({\n    data,\n    xScale: xScaleSpec = LineDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = LineDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = LineDefaultProps.colors,\n    curve = LineDefaultProps.curve,\n    areaBaselineValue = LineDefaultProps.areaBaselineValue,\n    pointColor = LineDefaultProps.pointColor,\n    pointBorderColor = LineDefaultProps.pointBorderColor,\n    enableSlices = LineDefaultProps.enableSlicesTooltip,\n}) => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState([])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries(\n                data.filter(item => hiddenIds.indexOf(item.id) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(line => ({\n            id: line.id,\n            label: line.id,\n            color: getColor(line),\n        }))\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(serie => serie.id === datum.id),\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id))\n        const legendData = dataWithColor\n            .map(item => ({ ...item, hidden: !series.find(serie => serie.id === item.id) }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator({ curve })\n    const areaGenerator = useAreaGenerator({\n        curve,\n        yScale,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    }\n}\n","import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\n\nconst AreaPath = ({ areaBlendMode, areaOpacity, color, fill, path }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst Areas = ({ areaGenerator, areaOpacity, areaBlendMode, lines }) => {\n    const computedLines = lines.slice(0).reverse()\n\n    return (\n        <g>\n            {computedLines.map(line => (\n                <AreaPath\n                    key={line.id}\n                    path={areaGenerator(line.data.map(d => d.position))}\n                    {...{ areaOpacity, areaBlendMode, ...line }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Areas)\n","import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\n\nconst LinesItem = ({ lineGenerator, points, color, thickness }) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport default memo(LinesItem)\n","import { memo } from 'react'\nimport LinesItem from './LinesItem'\n\nconst Lines = ({ lines, lineGenerator, lineWidth }) => {\n    return lines\n        .slice(0)\n        .reverse()\n        .map(({ id, data, color }) => (\n            <LinesItem\n                key={id}\n                id={id}\n                points={data.map(d => d.position)}\n                lineGenerator={lineGenerator}\n                color={color}\n                thickness={lineWidth}\n            />\n        ))\n}\n\nexport default memo(Lines)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst SlicesItem = ({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter && onMouseEnter(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove && onMouseMove(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave && onMouseLeave(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            onClick && onClick(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart && onTouchStart(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        event => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove && onTouchMove(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        event => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd && onTouchEnd(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport default memo(SlicesItem)\n","import { memo } from 'react'\nimport SlicesItem from './SlicesItem'\n\nconst Slices = ({\n    slices,\n    axis,\n    debug,\n    height,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}) => {\n    return slices.map(slice => (\n        <SlicesItem\n            key={slice.id}\n            slice={slice}\n            slices={slices}\n            axis={axis}\n            debug={debug}\n            height={height}\n            tooltip={tooltip}\n            setCurrent={setCurrent}\n            isCurrent={current !== null && current.id === slice.id}\n            onMouseEnter={onMouseEnter}\n            onMouseMove={onMouseMove}\n            onMouseLeave={onMouseLeave}\n            onClick={onClick}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMove}\n            onTouchEnd={onTouchEnd}\n        />\n    ))\n}\n\nexport default memo(Slices)\n","import { memo } from 'react'\nimport { getLabelGenerator, DotsItem, useTheme } from '@nivo/core'\n\nconst Points = ({ points, symbol, size, borderWidth, enableLabel, label, labelYOffset }) => {\n    const theme = useTheme()\n    const getLabel = getLabelGenerator(label)\n\n    /**\n     * We reverse the `points` array so that points from the lower lines in stacked lines\n     * graph are drawn on top. See https://github.com/plouc/nivo/issues/1051.\n     */\n    const mappedPoints = points\n        .slice(0)\n        .reverse()\n        .map(point => {\n            const mappedPoint = {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n            }\n\n            return mappedPoint\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    theme={theme}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport default memo(Points)\n","import { createElement, memo, useCallback } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\n\nconst Mesh = ({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter && onMouseEnter(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove && onMouseMove(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onMouseLeave && onMouseLeave(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        (point, event) => {\n            onClick && onClick(point, event)\n        },\n        [onClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart && onTouchStart(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point, event) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove && onTouchMove(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point, event) => {\n            hideTooltip()\n            onTouchEnd && onTouchEnd(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onClick={handleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport default memo(Mesh)\n","import { Fragment, useState } from 'react'\nimport {\n    bindDefs,\n    withContainer,\n    useDimensions,\n    useTheme,\n    SvgWrapper,\n    CartesianMarkers,\n} from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair } from '@nivo/tooltip'\nimport { useLine } from './hooks'\nimport Areas from './Areas'\nimport Lines from './Lines'\nimport Slices from './Slices'\nimport Points from './Points'\nimport Mesh from './Mesh'\nimport PointTooltip from './PointTooltip'\nimport SliceTooltip from './SliceTooltip'\n\nconst Line = props => {\n    const {\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n        curve = 'linear',\n        areaBaselineValue = 0,\n\n        colors = { scheme: 'nivo' },\n\n        margin: partialMargin,\n        width,\n        height,\n\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n        enableGridX = true,\n        enableGridY = true,\n        gridXValues,\n        gridYValues,\n\n        lineWidth = 2,\n        enableArea = false,\n        areaOpacity = 0.2,\n        areaBlendMode = 'normal',\n\n        enablePoints = true,\n        pointSymbol,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n        enablePointLabel = false,\n        pointLabel = 'data.yFormatted',\n        pointLabelYOffset,\n\n        defs = [],\n        fill = [],\n\n        markers,\n\n        legends = [],\n\n        isInteractive = true,\n\n        useMesh = false,\n        debugMesh = false,\n\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n\n        tooltip = PointTooltip,\n\n        enableSlices = false,\n        debugSlices = false,\n        sliceTooltip = SliceTooltip,\n\n        enableCrosshair = true,\n        crosshairType = 'bottom-left',\n        enableTouchCrosshair = false,\n\n        role = 'img',\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSerie,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n    })\n\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n\n    const [currentPoint, setCurrentPoint] = useState(null)\n    const [currentSlice, setCurrentSlice] = useState(null)\n\n    const layerById = {\n        grid: (\n            <Grid\n                key=\"grid\"\n                theme={theme}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        ),\n        markers: (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n                theme={theme}\n            />\n        ),\n        axes: (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                theme={theme}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        ),\n        areas: null,\n        lines: (\n            <Lines key=\"lines\" lines={series} lineGenerator={lineGenerator} lineWidth={lineWidth} />\n        ),\n        slices: null,\n        points: null,\n        crosshair: null,\n        mesh: null,\n        legends: legends.map((legend, i) => (\n            <BoxLegendSvg\n                key={`legend.${i}`}\n                {...legend}\n                containerWidth={innerWidth}\n                containerHeight={innerHeight}\n                data={legend.data || legendData}\n                theme={theme}\n                toggleSerie={legend.toggleSerie ? toggleSerie : undefined}\n            />\n        )),\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                lines={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                height={innerHeight}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                color={getPointColor}\n                borderWidth={pointBorderWidth}\n                borderColor={getPointBorderColor}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                current={currentPoint}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onClick={onClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return (\n                        <Fragment key={i}>\n                            {layer({\n                                ...props,\n                                innerWidth,\n                                innerHeight,\n                                series,\n                                slices,\n                                points,\n                                xScale,\n                                yScale,\n                                lineGenerator,\n                                areaGenerator,\n                                currentPoint,\n                                setCurrentPoint,\n                                currentSlice,\n                                setCurrentSlice,\n                            })}\n                        </Fragment>\n                    )\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport default withContainer(Line)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport Line from './Line'\n\nconst ResponsiveLine = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Line width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveLine\n","import { createElement, useRef, useEffect, useState, useCallback, forwardRef } from 'react'\nimport {\n    withContainer,\n    useDimensions,\n    useTheme,\n    getRelativeCursor,\n    isCursorInRect,\n} from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { useLine } from './hooks'\nimport PointTooltip from './PointTooltip'\n\nconst LineCanvas = props => {\n    const canvasEl = useRef(null)\n    const {\n        width,\n        height,\n        margin: partialMargin,\n        pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n\n        data,\n        xScale: xScaleSpec = { type: 'point' },\n        xFormat,\n        yScale: yScaleSpec = {\n            type: 'linear',\n            min: 0,\n            max: 'auto',\n        },\n        yFormat,\n        curve = 'linear',\n\n        layers = [\n            'grid',\n            'markers',\n            'axes',\n            'areas',\n            'crosshair',\n            'lines',\n            'points',\n            'slices',\n            'mesh',\n            'legends',\n        ],\n\n        colors = { scheme: 'nivo' },\n        lineWidth = 2,\n\n        enableArea = false,\n        areaBaselineValue = 0,\n        areaOpacity = 0.2,\n\n        enablePoints = true,\n        pointSize = 6,\n        pointColor = { from: 'color' },\n        pointBorderWidth = 0,\n        pointBorderColor = { theme: 'background' },\n\n        enableGridX = true,\n        gridXValues,\n        enableGridY = true,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = {},\n        axisLeft = {},\n\n        legends = [],\n\n        isInteractive = true,\n        debugMesh = false,\n        //onMouseEnter,\n        //onMouseMove,\n        onMouseLeave,\n        onClick,\n        tooltip = PointTooltip,\n        canvasRef,\n    } = props\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasRef) {\n            canvasRef.current = canvasEl.current\n        }\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer({\n                    ctx,\n                    innerWidth,\n                    innerHeight,\n                    series,\n                    points,\n                    xScale,\n                    yScale,\n                    lineWidth,\n                    lineGenerator,\n                    areaGenerator,\n                    currentPoint,\n                    setCurrentPoint,\n                })\n            }\n\n            if (layer === 'grid' && theme.grid.line.strokeWidth > 0) {\n                ctx.lineWidth = theme.grid.line.strokeWidth\n                ctx.strokeStyle = theme.grid.line.stroke\n\n                enableGridX &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n\n                enableGridY &&\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(serie => {\n                    ctx.strokeStyle = serie.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(serie.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.index)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        outerWidth,\n        outerHeight,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        currentPoint,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        event => {\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        event => {\n            hideTooltip()\n            setCurrentPoint(null)\n            currentPoint && onMouseLeave && onMouseLeave(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave]\n    )\n\n    const handleClick = useCallback(\n        event => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                point && onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nconst LineCanvasWithContainer = withContainer(LineCanvas)\n\nexport default forwardRef((props, ref) => <LineCanvasWithContainer {...props} canvasRef={ref} />)\n","import { forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport LineCanvas from './LineCanvas'\n\nconst ResponsiveLineCanvas = (props, ref) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <LineCanvas width={width} height={height} {...props} ref={ref} />}\n    </ResponsiveWrapper>\n)\n\nexport default forwardRef(ResponsiveLineCanvas)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}